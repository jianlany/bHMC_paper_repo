#!/usr/bin/env python3
"""
This script extracts information from the log files hmc.log generated by HMC runs.
"""
import sys
import os
import re


def log_reader(logfile, start = 0, intv = 1, end = None, ignore_state_candidates = False):
    hmc_steps = []
    with open(logfile, 'r') as f:
        read = False
        for line in f:
            if '-Step ' in line: 
                m = re.match('.*-Step (\d+), substep (\d+).*', line)
                step, substep = [int(n) for n in m.groups()]
                if step < start: 
                    read = False
                    continue
                elif (step - start)%intv != 0: 
                    read = False
                    continue
                elif (end is not None) and (step > end): 
                    read = False
                    break
                else:
                    read = True
                hmc_step = HMC_step(step, substep)
                print('new step: {} {}'.format(step, substep))
                continue
            if not read: continue
            m = re.match('.*Initial total energy: (\d+\.\d+) kcal\/mol', line)
            if m:
                initial_energy = float(m.group(1))
                hmc_step.initial_te = initial_energy
                # print('Initial energy logged: {}'.format(initial_energy))
                continue
            m = re.match('.*There are (\d+) tails, (\d+) loops, and (\d+) bridges after bond attack.*', line)
            if m:
                # Note that it is always AFTER the bond attack
                hmc_step.num_tails, hmc_step.num_loops, hmc_step.num_bridges = \
                        [int(n) for n in m.groups()]
                # print('Number of segments logged')
                continue
            m = re.match('.*There are (\d+) tail atoms, (\d+) loops* atoms\s*, and (\d+) bridge atoms after bond attack at step.*', line)
            if m:
                # Note that this is also AFTER the bond attack
                hmc_step.num_tail_atoms, \
                        hmc_step.num_loop_atoms, \
                        hmc_step.num_bridge_atoms = [int(n) for n in m.groups()]
                hmc_step.mean_tail_length = hmc_step.num_tail_atoms/hmc_step.num_tails if hmc_step.num_tails else 0
                hmc_step.mean_loop_length = hmc_step.num_loop_atoms/hmc_step.num_loops if hmc_step.num_loops else 0
                hmc_step.mean_bridge_length = hmc_step.num_bridge_atoms/hmc_step.num_bridges if hmc_step.num_bridges else 0
                # print("number of segment atoms logged.")
                continue
            if not ignore_state_candidates:
                m = re.match('.*state (\d+):$', line)
                if m:
                    state_num = int(m.group(1))
                    state = Attack_state(state_num)
                    # print('state candidate logged, state {}'.format(state_num))
                    hmc_step.state_candidates.append(state)
                    state = hmc_step.state_candidates[-1]
                    continue
                m = re.match('.*Resulting mean length of (tails|loops|bridges):\s+(\d+\.\d+), target: (\d+\.\d+).*', line)
                if m:
                    seg_type, mean_length, target_mean = m.groups()
                    # print('State params found, type: {}, mean: {}'.format(seg_type, mean_length))
                    mean_length, target_mean = float(mean_length), float(target_mean)
                    assert (seg_type not in state.mean_lengths) and (seg_type not in state.target_means)
                    state.mean_lengths[seg_type] = mean_length
                    state.target_means[seg_type] = target_mean
                m = re.match('.*relative p: (\d+\.\d+e*-*\d*).*', line)
                if m:
                    state.p = float(m.group(1))
                    # print('State probability found, {}'.format(state.p))
                    continue
                m = re.match('.*State (\d+) is selected.*', line)
                if m:
                    state_num = int(m.group(1))
                    hmc_step.selected_state_num = state_num
                    # print('Selected state num found: {}'.format(state_num))


            m = re.match('.*Final total energy of .*: (\d+\.\d+) kcal/mol', line)
            if m:
                hmc_step.final_te = float(m.group(1))
                hmc_steps.append(hmc_step)
                # print('Final te found, {}.'.format(hmc_step.final_te))
    return hmc_steps



class HMC_step:
    def __init__(self, step, substep):
        self.step = step
        self.substep = substep
        self.state_candidates = []
        self.selected_state_num = None
        self.num_tails = None
        self.num_loops = None
        self.num_bridges = None
        self.initial_te = None
        self.final_te = None


class Attack_state:
    def __init__(self, state_num):
        self.state_num = state_num
        self.mean_lengths = {}
        self.target_means = {}
    def __repr__(self):
        string = 'State number {}.\n'.format(self.state_num) \
               + '\tmean lengths: {}'.format(repr(self.mean_lengths))
        return string

if __name__ == "__main__":
    log_reader(sys.argv[1])
